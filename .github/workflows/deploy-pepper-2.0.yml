name: üöÄ Deploy Pepper 2.0 to AWS EC2

on:
  push:
    branches:
      - main
      - production
    paths:
      - 'frontend/**'
      - 'backend/**'
      - '.github/workflows/deploy-pepper-2.0.yml'
  workflow_dispatch:
    inputs:
      deploy_lambda:
        description: 'Deploy Lambda functions'
        required: false
        default: 'true'
        type: boolean

env:
  NODE_VERSION: '20.x'
  EC2_APP_PATH: '/opt/pepper-2.0'
  EC2_DOMAIN: 'pepper20.emtechnologysolutions.com'

jobs:
  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci

      - name: Build frontend
        working-directory: frontend
        env:
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL || 'https://pepper20.emtechnologysolutions.com' }}
        run: npm run build

      - name: Upload frontend build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: |
            frontend/.next
            frontend/public
            frontend/app
            frontend/components
            frontend/lib
            frontend/providers
            frontend/hooks
            frontend/package.json
            frontend/package-lock.json
            frontend/next.config.js
            frontend/tsconfig.json
            frontend/tailwind.config.js
            frontend/postcss.config.js
            frontend/next-env.d.ts
          retention-days: 1

  deploy-backend:
    name: Deploy Backend to EC2
    runs-on: ubuntu-latest
    needs: build-frontend
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download frontend build artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: frontend

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Add EC2 to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Test SSH connection
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo '‚úÖ SSH connection successful'"

      - name: Create backup on EC2
        run: |
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            BACKUP_DIR="$HOME/backups/pepper-2.0"
            mkdir -p "$BACKUP_DIR"
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            
            if [ -d "${{ env.EC2_APP_PATH }}/backend" ]; then
              echo "üì¶ Creating backend backup..."
              tar -czf "$BACKUP_DIR/backend-$TIMESTAMP.tar.gz" -C "${{ env.EC2_APP_PATH }}/backend" \
                --exclude='node_modules' \
                --exclude='.git' \
                --exclude='cases' \
                --exclude='*.log' \
                .
              echo "‚úÖ Backend backup created: backend-$TIMESTAMP.tar.gz"
              
              # Keep only last 5 backups
              ls -t "$BACKUP_DIR"/backend-*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm || true
            fi
            
            if [ -d "${{ env.EC2_APP_PATH }}/frontend" ]; then
              echo "üì¶ Creating frontend backup..."
              tar -czf "$BACKUP_DIR/frontend-$TIMESTAMP.tar.gz" -C "${{ env.EC2_APP_PATH }}/frontend" \
                --exclude='node_modules' \
                --exclude='.git' \
                --exclude='.next' \
                .
              echo "‚úÖ Frontend backup created: frontend-$TIMESTAMP.tar.gz"
              
              # Keep only last 5 backups
              ls -t "$BACKUP_DIR"/frontend-*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm || true
            fi
          EOF

      - name: Stop PM2 processes
        run: |
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "pm2 stop pepper-2.0-backend pepper-2.0-frontend || true"

      - name: Sync backend files to EC2
        run: |
          rsync -avz --delete \
            --exclude='node_modules' \
            --exclude='.git' \
            --exclude='cases' \
            --exclude='*.log' \
            --exclude='.env' \
            --exclude='.next' \
            --exclude='frontend' \
            -e "ssh -o StrictHostKeyChecking=no" \
            . ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:${{ env.EC2_APP_PATH }}/

      - name: Verify backend .env on EC2
        run: |
          if ! ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "test -f ${{ env.EC2_APP_PATH }}/backend/.env"; then
            echo "::error::backend/.env not found on EC2 at ${{ env.EC2_APP_PATH }}/backend/.env"
            echo "Create it (e.g. MONGO_URI=..., PORT=3001) and re-run. Deploy excludes .env."
            exit 1
          fi
          echo "‚úÖ backend/.env exists"

      - name: Deploy frontend to EC2
        run: |
          echo "üì¶ Deploying frontend build to EC2..."
          rsync -avz --delete \
            --exclude='node_modules' \
            -e "ssh -o StrictHostKeyChecking=no" \
            frontend/ ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:${{ env.EC2_APP_PATH }}/frontend/
          echo "‚úÖ Frontend files synced to EC2"

      - name: Install frontend dependencies on EC2
        run: |
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ${{ env.EC2_APP_PATH }}/frontend
            echo "üì¶ Installing frontend dependencies (including devDependencies for build)..."
            npm ci
            echo "‚úÖ Frontend dependencies installed"
          EOF

      - name: Install backend dependencies
        run: |
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ${{ env.EC2_APP_PATH }}/backend
            echo "üì¶ Installing dependencies..."
            npm ci --production
            echo "‚úÖ Dependencies installed"
          EOF

      - name: Restart PM2 process
        run: |
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ${{ env.EC2_APP_PATH }}/backend
            echo "üîÑ Removing existing PM2 process (ensures fresh config from ecosystem.config.cjs)..."
            pm2 delete pepper-2.0-backend 2>/dev/null || true
            echo "üöÄ Starting backend from ecosystem.config.cjs..."
            pm2 start ecosystem.config.cjs
            pm2 save
            echo "‚úÖ PM2 process started and saved"
          EOF

      - name: Start frontend with PM2
        run: |
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            cd ${{ env.EC2_APP_PATH }}/frontend
            echo "üîÑ Removing existing frontend PM2 process..."
            pm2 delete pepper-2.0-frontend 2>/dev/null || true
            echo "üöÄ Starting frontend Next.js server..."
            pm2 start npm --name "pepper-2.0-frontend" --cwd "${{ env.EC2_APP_PATH }}/frontend" -- start
            pm2 save
            echo "‚úÖ Frontend PM2 process started and saved"
          EOF

      - name: PM2 status and startup logs
        run: |
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'REMOTE'
            echo "=== PM2 status ==="
            pm2 status
            echo ""
            echo "=== Backend logs (last 30 lines) ==="
            pm2 logs pepper-2.0-backend --lines 30 --nostream
            echo ""
            echo "=== Frontend logs (last 30 lines) ==="
            pm2 logs pepper-2.0-frontend --lines 30 --nostream
          REMOTE

      - name: Wait for application startup
        run: sleep 10

      - name: Health check
        id: health
        run: |
          echo "üîç Waiting for backend to be ready..."
          for i in 1 2 3 4 5 6 7 8 9 10; do
            RAW=$(ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "curl -s -o /dev/null -w '%{http_code}' http://localhost:3001/health 2>/dev/null || echo '000'")
            HEALTH=$(printf '%s' "$RAW" | tr -d '\n\r' | head -c 3)
            [ -z "$HEALTH" ] && HEALTH="000"
            if [ "$HEALTH" = "200" ]; then
              BODY=$(ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "curl -s http://localhost:3001/health")
              echo "health_response=$BODY" >> $GITHUB_OUTPUT
              echo "Health check response: $BODY"
              echo "‚úÖ Health check passed (attempt $i)"
              exit 0
            fi
            echo "   Attempt $i: HTTP $HEALTH, retrying in 5s..."
            sleep 5
          done
          echo "health_response=FAILED (no response after 10 attempts)" >> $GITHUB_OUTPUT
          echo "‚ùå Health check failed: backend did not respond within ~60s"
          exit 1

      - name: Get PM2 logs on failure
        if: failure()
        run: |
          ssh ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            echo "=== PM2 status ==="
            pm2 status
            echo ""
            echo "=== PM2 logs (last 50 lines) ==="
            pm2 logs pepper-2.0-backend --lines 50 --nostream
          EOF

      - name: Deployment summary
        if: success()
        run: |
          echo "## ‚úÖ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend:** Deployed to EC2 (port 3001)" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend:** Deployed to EC2 (port 3000)" >> $GITHUB_STEP_SUMMARY
          echo "- **Domain:** ${{ env.EC2_DOMAIN }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Health Check:** ${{ steps.health.outputs.health_response }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PM2 Status:** Backend and Frontend running" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è **Note:** Configure nginx to proxy:" >> $GITHUB_STEP_SUMMARY
          echo "- \`/\` and \`/_next\` ‚Üí http://localhost:3000 (frontend)" >> $GITHUB_STEP_SUMMARY
          echo "- \`/api\` and \`/health\` ‚Üí http://localhost:3001 (backend)" >> $GITHUB_STEP_SUMMARY

  deploy-lambda:
    name: Deploy Lambda Functions
    runs-on: ubuntu-latest
    # Run on:
    # 1. Manual trigger (workflow_dispatch) - always runs
    # 2. Push to main/production (backend files are already in paths filter)
    # Note: Lambda deployment runs when backend/** changes, which includes
    # lambda handlers, services, lib, utils, models that Lambda functions depend on
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && 
       (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'))
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Install backend dependencies
        working-directory: backend
        run: npm ci

      - name: Make package script executable
        working-directory: backend/lambda
        run: chmod +x package-lambda.sh

      - name: Package Lambda functions
        working-directory: backend/lambda
        run: |
          echo "üì¶ Packaging Lambda functions..."
          ./package-lambda.sh caseCleanupHandler
          ./package-lambda.sh calendarNotificationHandler
          ./package-lambda.sh cpnuSyncHandler
          echo "‚úÖ All Lambda functions packaged"

      - name: Upload Lambda packages as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-packages
          path: |
            backend/lambda/*.zip
          retention-days: 1

      - name: Deploy caseCleanupHandler
        working-directory: backend/lambda
        run: |
          FUNCTION_NAME="pepper-2.0-case-cleanup"
          ZIP_FILE="caseCleanupHandler.zip"
          
          echo "üöÄ Deploying $FUNCTION_NAME..."
          
          # Check if function exists
          if aws lambda get-function --function-name "$FUNCTION_NAME" 2>/dev/null; then
            echo "üì¶ Function exists, updating code..."
            aws lambda update-function-code \
              --function-name "$FUNCTION_NAME" \
              --zip-file "fileb://$ZIP_FILE" \
              --output json > /tmp/update-result.json
            
            # Wait for update to complete
            aws lambda wait function-updated --function-name "$FUNCTION_NAME"
            
            echo "‚úÖ Function code updated"
          else
            echo "‚ö†Ô∏è  Function does not exist. Creating function..."
            echo "   Note: Function creation requires IAM role ARN in secrets.AWS_LAMBDA_ROLE_ARN"
            
            if [ -z "${{ secrets.AWS_LAMBDA_ROLE_ARN }}" ]; then
              echo "::error::AWS_LAMBDA_ROLE_ARN secret not set. Cannot create function."
              echo "   Please create the function manually or set AWS_LAMBDA_ROLE_ARN secret."
              exit 1
            fi
            
            # Get MONGO_URI from Parameter Store or use secret
            MONGO_URI="${{ secrets.MONGO_URI }}"
            if [ -z "$MONGO_URI" ]; then
              echo "::warning::MONGO_URI not found in secrets. Function will need environment variables configured."
            fi
            
            aws lambda create-function \
              --function-name "$FUNCTION_NAME" \
              --runtime nodejs20.x \
              --role "${{ secrets.AWS_LAMBDA_ROLE_ARN }}" \
              --handler "lambda/caseCleanupHandler.handler" \
              --zip-file "fileb://$ZIP_FILE" \
              --timeout 300 \
              --memory-size 512 \
              --environment "Variables={MONGO_URI=$MONGO_URI,TZ=America/New_York}" \
              --description "Pepper 2.0: Clean up closed cases after retention period" \
              --output json > /tmp/create-result.json
            
            echo "‚úÖ Function created"
          fi
          
          # Get function ARN for EventBridge
          FUNCTION_ARN=$(aws lambda get-function --function-name "$FUNCTION_NAME" --query 'Configuration.FunctionArn' --output text)
          echo "Function ARN: $FUNCTION_ARN"
          echo "function_arn=$FUNCTION_ARN" >> $GITHUB_OUTPUT

      - name: Deploy calendarNotificationHandler
        working-directory: backend/lambda
        run: |
          FUNCTION_NAME="pepper-2.0-calendar-notifications"
          ZIP_FILE="calendarNotificationHandler.zip"
          
          echo "üöÄ Deploying $FUNCTION_NAME..."
          
          if aws lambda get-function --function-name "$FUNCTION_NAME" 2>/dev/null; then
            echo "üì¶ Function exists, updating code..."
            aws lambda update-function-code \
              --function-name "$FUNCTION_NAME" \
              --zip-file "fileb://$ZIP_FILE" \
              --output json > /tmp/update-result.json
            
            aws lambda wait function-updated --function-name "$FUNCTION_NAME"
            echo "‚úÖ Function code updated"
          else
            echo "‚ö†Ô∏è  Function does not exist. Creating function..."
            
            if [ -z "${{ secrets.AWS_LAMBDA_ROLE_ARN }}" ]; then
              echo "::error::AWS_LAMBDA_ROLE_ARN secret not set. Cannot create function."
              exit 1
            fi
            
            MONGO_URI="${{ secrets.MONGO_URI }}"
            
            aws lambda create-function \
              --function-name "$FUNCTION_NAME" \
              --runtime nodejs20.x \
              --role "${{ secrets.AWS_LAMBDA_ROLE_ARN }}" \
              --handler "lambda/calendarNotificationHandler.handler" \
              --zip-file "fileb://$ZIP_FILE" \
              --timeout 300 \
              --memory-size 512 \
              --environment "Variables={MONGO_URI=$MONGO_URI,TZ=America/New_York}" \
              --description "Pepper 2.0: Send WhatsApp notifications for upcoming calendar events" \
              --output json > /tmp/create-result.json
            
            echo "‚úÖ Function created"
          fi
          
          FUNCTION_ARN=$(aws lambda get-function --function-name "$FUNCTION_NAME" --query 'Configuration.FunctionArn' --output text)
          echo "Function ARN: $FUNCTION_ARN"
          echo "function_arn=$FUNCTION_ARN" >> $GITHUB_OUTPUT

      - name: Deploy cpnuSyncHandler
        working-directory: backend/lambda
        run: |
          FUNCTION_NAME="pepper-2.0-cpnu-sync"
          ZIP_FILE="cpnuSyncHandler.zip"
          
          echo "üöÄ Deploying $FUNCTION_NAME..."
          
          if aws lambda get-function --function-name "$FUNCTION_NAME" 2>/dev/null; then
            echo "üì¶ Function exists, updating code..."
            aws lambda update-function-code \
              --function-name "$FUNCTION_NAME" \
              --zip-file "fileb://$ZIP_FILE" \
              --output json > /tmp/update-result.json
            
            aws lambda wait function-updated --function-name "$FUNCTION_NAME"
            echo "‚úÖ Function code updated"
          else
            echo "‚ö†Ô∏è  Function does not exist. Creating function..."
            
            if [ -z "${{ secrets.AWS_LAMBDA_ROLE_ARN }}" ]; then
              echo "::error::AWS_LAMBDA_ROLE_ARN secret not set. Cannot create function."
              exit 1
            fi
            
            MONGO_URI="${{ secrets.MONGO_URI }}"
            
            aws lambda create-function \
              --function-name "$FUNCTION_NAME" \
              --runtime nodejs20.x \
              --role "${{ secrets.AWS_LAMBDA_ROLE_ARN }}" \
              --handler "lambda/cpnuSyncHandler.handler" \
              --zip-file "fileb://$ZIP_FILE" \
              --timeout 300 \
              --memory-size 512 \
              --environment "Variables={MONGO_URI=$MONGO_URI,TZ=America/Bogota}" \
              --description "Pepper 2.0: Sync CPNU actuaciones for linked cases" \
              --output json > /tmp/create-result.json
            
            echo "‚úÖ Function created"
          fi
          
          FUNCTION_ARN=$(aws lambda get-function --function-name "$FUNCTION_NAME" --query 'Configuration.FunctionArn' --output text)
          echo "Function ARN: $FUNCTION_ARN"
          echo "function_arn=$FUNCTION_ARN" >> $GITHUB_OUTPUT

      - name: Verify Lambda deployments
        run: |
          echo "üîç Verifying Lambda function deployments..."
          
          FUNCTIONS=(
            "pepper-2.0-case-cleanup"
            "pepper-2.0-calendar-notifications"
            "pepper-2.0-cpnu-sync"
          )
          
          for func in "${FUNCTIONS[@]}"; do
            if aws lambda get-function --function-name "$func" > /dev/null 2>&1; then
              STATUS=$(aws lambda get-function --function-name "$func" --query 'Configuration.State' --output text)
              LAST_MODIFIED=$(aws lambda get-function --function-name "$func" --query 'Configuration.LastModified' --output text)
              echo "‚úÖ $func: $STATUS (Last modified: $LAST_MODIFIED)"
            else
              echo "‚ùå $func: Function not found"
            fi
          done

      - name: Lambda deployment summary
        if: success()
        run: |
          echo "## ‚úÖ Lambda Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployed Functions:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. **pepper-2.0-case-cleanup**" >> $GITHUB_STEP_SUMMARY
          echo "   - Schedule: Daily at 2:00 AM (America/New_York)" >> $GITHUB_STEP_SUMMARY
          echo "   - Handler: lambda/caseCleanupHandler.handler" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "2. **pepper-2.0-calendar-notifications**" >> $GITHUB_STEP_SUMMARY
          echo "   - Schedule: Every 5 minutes (America/New_York)" >> $GITHUB_STEP_SUMMARY
          echo "   - Handler: lambda/calendarNotificationHandler.handler" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "3. **pepper-2.0-cpnu-sync**" >> $GITHUB_STEP_SUMMARY
          echo "   - Schedule: 12:00 PM and 7:00 PM daily (America/Bogota)" >> $GITHUB_STEP_SUMMARY
          echo "   - Handler: lambda/cpnuSyncHandler.handler" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. ‚ö†Ô∏è **Configure EventBridge Rules** (if not already done):" >> $GITHUB_STEP_SUMMARY
          echo "   - Create EventBridge rules to trigger Lambda functions on schedule" >> $GITHUB_STEP_SUMMARY
          echo "   - See \`backend/lambda/README.md\` for schedule details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "2. üîç **Verify Lambda execution:**" >> $GITHUB_STEP_SUMMARY
          echo "   - Check CloudWatch logs for each function" >> $GITHUB_STEP_SUMMARY
          echo "   - Test functions manually if needed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "3. üö´ **Disable EC2 cron jobs** (after verifying Lambda works):" >> $GITHUB_STEP_SUMMARY
          echo "   - Run \`backend/scripts/disable-ec2-cron.sh\` on EC2" >> $GITHUB_STEP_SUMMARY
          echo "   - See \`backend/scripts/CRON_MIGRATION_GUIDE.md\` for details" >> $GITHUB_STEP_SUMMARY
